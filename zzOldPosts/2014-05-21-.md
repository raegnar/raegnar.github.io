---
layout: post
title: Avoiding Compute Shaders
date: 2014-05-21 09:24
author: randallr
comments: true
categories: [Uncategorized]
---
So the trick is to render an instanced list of triangles that cover the viewport, one triangle per volume slice

glViewport(0, 0, w, h);   //set viewport to voxel dimensions //set shader uniforms somewhere glBindVertexArray(someVAO);        //this is an openglism and pointlessglDrawArraysInstanced(GL_TRIANGLE_STRIP, 0, 3, d); //Render d triangles

You can probably create an actual triangle list, but I just move the point where I need them in the vertex shader.

//In the fragment shader ivec3(x,y,instanceID) will provide //coordinates for the volume flat out int instanceID;void main(){         float x = -1.0 + float((gl_VertexID &amp; 1) &lt;&lt; 2);         float y = -1.0 + float((gl_VertexID &amp; 2) &lt;&lt; 1);         instanceID  = gl_InstanceID;         gl_Position = vec4(x, y, 0, 1);}

&nbsp;

This one is for openGL, but this site discusses the technique for directx: <a href="http://www.altdevblogaday.com/2011/08/08/interesting-vertex-shader-trick/">http://www.altdevblogaday.com/2011/08/08/interesting-vertex-shader-trick/</a>

Then in the fragment shader your voxel coordinate is just

flat in int instanceID;void main(){         ivec3 voxelCoord = ivec3(gl_FragCoord.xy,instanceID);}

Which you can use however you like.

So with the addition of a trivial vertex shader, setting the viewport, and performing a different draw call you’ve essentially reproduced a compute shader with better cache coherence (but no access to shared memory).
