---
layout: post
title: Voxelization
date: 2011-09-25 15:20
author: randallr
comments: true
categories: [Uncategorized]
---
I'm a big believer in voxels, not so much as a replacement for triangle geometry, but as a useful proxy for triangle geometry.  So I'm always interested in finding the fastest voxelization possible.

Lately I've been trying to implement the voxelization techniques seen in "Fast Parallel Surface and Solid Voxelization on GPUs" and "<a href="http://research.nvidia.com/publication/voxelpipe-programmable-pipeline-3d-voxelization">VoxelPipe: A Programmable Pipeline for 3D Voxelization</a>"

Both papers are based on roughly the same triangle-voxel intersection technique.

The first step is to determine a conservative set of potentially intersected voxels

[sourcecode language="cpp"]
tri_min_voxel_index.x = FW::clamp((int)(triAABB.min.x * volume_dim.x - 0.5f), 0, w-1);
tri_min_voxel_index.y = FW::clamp((int)(triAABB.min.y * volume_dim.y - 0.5f), 0, h-1);
tri_min_voxel_index.z = FW::clamp((int)(triAABB.min.z * volume_dim.z - 0.5f), 0, d-1);

tri_max_voxel_index.x = FW::clamp((int)(triAABB.max.x * volume_dim.x + 0.5f), 0, w-1);
tri_max_voxel_index.y = FW::clamp((int)(triAABB.max.y * volume_dim.y + 0.5f), 0, h-1);
tri_max_voxel_index.z = FW::clamp((int)(triAABB.max.z * volume_dim.z + 0.5f), 0, d-1);
[/sourcecode]

We can then naively iterate over these voxels and

[sourcecode language="cpp"]
for(int z = tri_min_voxel_index.z; z &lt;= tri_max_voxel_index.z; z++)
for(int y = tri_min_voxel_index.y; y &lt;= tri_max_voxel_index.y; y++)
for(int x = tri_min_voxel_index.x; x &lt;= tri_max_voxel_index.x; x++)
{
	//Triangle-Voxel intersection code goes here...
}
[/sourcecode]

After getting this to work, the next step is optimization, which takes two main approaches.  Minimizing the number of voxels to iterate over, and factoring out the intersection calculations as much as possible.
